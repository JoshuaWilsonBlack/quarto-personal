<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ready Player Me Blendshape Animation</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    a {
      color: #60a5fa;
    }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #111827;
      color: white;
      display: flex;
      flex-direction: row; /* Change from column to row */
      height: 100vh;
      overflow: hidden;
    }
    .header {
      background: #191818;
      padding: 1rem;
      box-shadow: -2px 0 4px rgba(0,0,0,0.3); /* Shadow on left instead of bottom */
      width: 20%; /* Fixed width for the sidebar */
      height: 100vh; /* Full viewport height */
      max-height: none; /* Remove the max-height restriction */
      overflow-y: auto;
      position: fixed; /* Fix it to the viewport */
      right: 0; /* Align to right edge */
      top: 0;
    }
    h1 {
      font-size: 1.5rem;
      margin-bottom: 0.75rem;
    }
    .info-box {
      background:#191818;
      padding: 0.75rem;
      border-radius: 0.375rem;
      margin-bottom: 1rem;
    }
    .info-box p {
      color: #bfdbfe;
      font-size: 0.875rem;
      margin-bottom: 0.5rem;
    }
    .info-box ol {
      color: #bfdbfe;
      font-size: 0.875rem;
      margin-left: 1.25rem;
    }
    .info-box ol li {
      margin-bottom: 0.25rem;
    }
    .info-box a {
      color: #60a5fa;
      text-decoration: underline;
    }
    .url-input-group {
      display: block;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    .url-input-group input {
      padding: 0.5rem;
      background: #374151;
      color: white;
      border: 1px solid #4b5563;
      border-radius: 0.375rem;
      font-size: 0.875rem;
    }
    .url-input-group button {
      padding: 0.5rem 1.5rem;
      background: #585C1F;
      color: white;
      border: none;
      border-radius: 0.375rem;
      font-weight: 500;
      cursor: pointer;
    }
    .url-input-group button:hover {
      background: #585C1F;
    }
    .url-input-group button:disabled {
      background: #4b5563;
      cursor: not-allowed;
    }
    .error {
      background: #7f1d1d;
      color: #fecaca;
      padding: 0.75rem;
      border-radius: 0.375rem;
      margin-bottom: 1rem;
      font-size: 0.875rem;
    }
    .controls-panel {
      padding: 1rem;
      border-bottom: 1px solid #374151;
    }
    .control-group {
      margin-bottom: 1rem;
    }
    .control-group:last-child {
      margin-bottom: 0;
    }
    .control-group label {
      display: block;
      color: #e5e7eb;
      font-size: 2rem;
      margin-bottom: 0.375rem;
      font-weight: 500;
    }
    .control-group select {
      width: 100%;
      padding: 0.5rem;
      background: #374151;
      color: white;
      border: 1px solid #4b5563;
      border-radius: 0.375rem;
      font-size: 0.875rem;
    }
    .slider-container {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    .slider-container input[type="range"] {
      flex: 1;
    }
    .slider-value {
      color: #60a5fa;
      font-weight: 600;
      min-width: 3rem;
      text-align: right;
      font-size: 0.875rem;
    }
    .button-group {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 1rem;
    }
    .button-group button {
      padding: 0.5rem 1rem;
      background: #585C1F;
      color: white;
      border: none;
      border-radius: 0.375rem;
      font-size: 0.875rem;
      cursor: pointer;
      font-weight: 500;
    }
    .button-group button:hover {
      background:rgb(52, 54, 14);
    }
    #container {
      flex: 1;
      position: relative;
      cursor: grab;
      margin-right: 20%; /* Add margin to account for fixed sidebar width */
    }
    #container:active {
      cursor: grabbing;
    }
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #585C1F;
      font-size: 1.25rem;
      font-weight: 500;
    }
  </style>
</head>
<body>
  <div class="header">
    
    <div class="controls-panel" id="controls" style="display: none;">
      
      <div class="control-group">
            <div class="button-group">
                <button id="btn-seq-1">Pause 1</button>
                <button id="btn-seq-2">Pause 2</button>
                <button id="btn-seq-3">Pause 3</button>
                <button id="btn-seq-4">Pause 4</button>
                <button id="btn-seq-5">Pause 5</button>
                <button id="btn-seq-6">Pause 6</button>
                <button id="btn-seq-7">Pause 7</button>
                <button id="btn-seq-8">Pause 8</button>
                <button id="reset-btn">Reset All</button>
            </div>
      </div>
    </div>

    <div class="url-input-group">
      <div>This model was created using <a href="https://readyplayer.me">Ready Player Me</a>, a service for creating 3D avatars.</div>
      <div>You can create your own model and load it here:</div>
      <input 
        type="text" 
        id="model-url" 
        placeholder="https://models.readyplayer.me/your-avatar-id.glb"
        value="">
      <button id="load-btn">Load Model</button>
    </div>

    <div id="error-msg" class="error" style="display: none;"></div>
  </div>
  
  <div id="container">
    <div id="loading" style="display: none;">Loading model...</div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>

  <script>
    /**
    * Animation controller for blendshape playback
    */
    class BlendshapeAnimator {
    constructor(morphTargetMesh, sequences, fps = 30) {
        this.mesh = morphTargetMesh;           // The THREE.js mesh with morph targets
        this.sequences = sequences;             // Parsed blendshape data
        this.fps = fps;                        // Frames per second
        this.frameDuration = 1000 / fps;       // Milliseconds per frame
        
        this.currentSequence = null;
        this.currentFrameIndex = 0;
        this.isPlaying = false;
        this.loop = false;
        this.animationId = null;
        this.lastFrameTime = 0;
    }

    /**
    * Play a specific sequence
    * @param {string} sequenceId - The sequence identifier
    * @param {boolean} loop - Whether to loop the animation
    */
    play(sequenceId, loop = false) {
        if (!this.sequences[sequenceId]) {
        console.error(`Sequence ${sequenceId} not found`);
        return;
        }

        // Stop current animation if playing
        this.stop();

        this.currentSequence = this.sequences[sequenceId];
        this.currentFrameIndex = 0;
        this.isPlaying = true;
        this.loop = loop;
        this.lastFrameTime = performance.now();

        this.animate();
    }

    /**
    * Animation loop
    */
    animate() {
        if (!this.isPlaying) return;

        const now = performance.now();
        const elapsed = now - this.lastFrameTime;

        // Check if enough time has passed for next frame
        if (elapsed >= this.frameDuration) {
        this.applyFrame(this.currentFrameIndex);
        this.lastFrameTime = now;
        this.currentFrameIndex++;

        // Check if sequence is complete
        if (this.currentFrameIndex >= this.currentSequence.length) {
                if (this.loop) {
                this.currentFrameIndex = 0;
            } else {
                this.stop();
                return;
            }
        }
        }

        this.animationId = requestAnimationFrame(() => this.animate());
    }

    /**
    * Apply blendshape values for a specific frame
    * @param {number} frameIndex - The frame index to apply
    */
    applyFrame(frameIndex) {
        const frameData = this.currentSequence[frameIndex];
        
        if (!frameData) return;

        // Get the dictionary of morph target influences
        const influences = this.mesh.morphTargetInfluences;
        const dictionary = this.mesh.morphTargetDictionary;

        // Apply each blendshape coefficient
        Object.keys(frameData).forEach(key => {
        // Skip frame and identifier columns (update this)
        if (key === 'frame' || key === 'identifier' || key === 'sequence_id' || key === 'id') {
            return;
        }

        // Check if this blendshape exists on the mesh (and apply?)
        if (dictionary && dictionary.hasOwnProperty(key)) {
            const index = dictionary[key];
            influences[index] = frameData[key];
        }
        });
    }

    /**
    * Pause the animation
    */
    pause() {
        this.isPlaying = false;
        if (this.animationId) {
        cancelAnimationFrame(this.animationId);
        this.animationId = null;
        }
    }

    /**
    * Resume the animation
    */
    resume() {
        if (!this.currentSequence || this.isPlaying) return;
        
        this.isPlaying = true;
        this.lastFrameTime = performance.now();
        this.animate();
    }

    /**
    * Stop and reset the animation
    */
    stop() {
        this.isPlaying = false;
        this.currentFrameIndex = 0;
        
        if (this.animationId) {
        cancelAnimationFrame(this.animationId);
        this.animationId = null;
        }
    }

    /**
    * Set playback speed
    * @param {number} fps - New frames per second
    */
    setFPS(fps) {
        this.fps = fps;
        this.frameDuration = 1000 / fps;
    }

    /**
    * Get current playback info
    */
    getStatus() {
        return {
        isPlaying: this.isPlaying,
        currentFrame: this.currentFrameIndex,
        totalFrames: this.currentSequence ? this.currentSequence.length : 0,
        sequenceId: this.currentSequence ? Object.keys(this.sequences).find(
            key => this.sequences[key] === this.currentSequence
        ) : null
        };
    }
    }
  </script>

  <script>
    // DOM elements
    const container = document.getElementById('container');
    const modelUrlInput = document.getElementById('model-url');
    const loadBtn = document.getElementById('load-btn');
    const loadingEl = document.getElementById('loading');
    const errorMsg = document.getElementById('error-msg');
    const controlsPanel = document.getElementById('controls');
    const resetBtn = document.getElementById('reset-btn');

    let scene, camera, renderer, controls;
    let headMesh = null;
    let model = null;
    let blendshapeSequences = null;
    let availableBlendshapes = [];
    let animator;

    // Initialize Three.js scene
    function initScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xF5F5F5);

      camera = new THREE.PerspectiveCamera(
        45,
        container.clientWidth / container.clientHeight,
        0.1,
        1000
      );
      camera.position.set(0, 0, 0.4);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.outputEncoding = THREE.sRGBEncoding;
      container.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.target.set(0, 0, 0);

      // Lighting - three-point setup
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const keyLight = new THREE.DirectionalLight(0xffffff, 0.8);
      keyLight.position.set(1, 1, 1);
      scene.add(keyLight);

      const fillLight = new THREE.DirectionalLight(0x6c63ff, 0.3);
      fillLight.position.set(-1, 0, -1);
      scene.add(fillLight);

      const backLight = new THREE.DirectionalLight(0xffffff, 0.2);
      backLight.position.set(0, 1, -1);
      scene.add(backLight);

      // Start animation loop
      animate();

      // Handle resize
      window.addEventListener('resize', () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      });
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    // Load model
    function loadModel(url) {
        showLoading(true);
        hideError();
        controlsPanel.style.display = 'none';

        // Remove previous model completely
        if (model) {
            scene.remove(model);
            model = null;
            headMesh = null;
        }
        
        // Stop any active animation
        if (animator) {
            animator.stop();
            animator = null;
        }

      const loader = new THREE.GLTFLoader();

      loader.load(
        url,
        (gltf) => {
          console.log('Model loaded successfully');
          model = gltf.scene;

          // Find mesh with morph targets
          let foundMesh = null;
          model.traverse((child) => {
            if (child.isMesh && child.morphTargetInfluences && child.morphTargetInfluences.length > 0) {
              foundMesh = child;
              console.log('Found mesh with morph targets:', child.name);
              console.log('Morph targets:', Object.keys(child.morphTargetDictionary || {}));
            }
          });

          if (foundMesh) {
            headMesh = foundMesh;
            availableBlendshapes = Object.keys(headMesh.morphTargetDictionary || {})
              .filter(key => !key.startsWith("viseme"));

            // Reset all influences
            headMesh.morphTargetInfluences.fill(0);

            
            // Add model to scene
            scene.add(model);

            // Center and scale model
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const scale = 2 / maxDim;
            model.scale.multiplyScalar(scale);
            box.setFromObject(model);
            box.getCenter(center);
            model.position.sub(center);
            
            // Find the head bone and position it at origin
            const leftEye = model.getObjectByName('LeftEye')
            const rightEye = model.getObjectByName('RightEye')
            
            if (leftEye) {
              const leftEyePosition = new THREE.Vector3();
              leftEye.getWorldPosition(leftEyePosition);
              const rightEyePosition = new THREE.Vector3();
              rightEye.getWorldPosition(rightEyePosition);
              middleOfEyes = leftEyePosition.clone().lerp(rightEyePosition, 0.5);
              model.position.sub(middleOfEyes);
              console.log('Middle of eyes positioned at origin');
            } else {
              console.warn('Head bone not found, using bounding box top instead');
              // Alternative: position top of bounding box at origin
              model.position.y += size.y * scale / 2;
            }
            

            console.log('Setup complete. Found', availableBlendshapes.length, 'blendshapes');

            if (blendshapeSequences) {
                console.log('CSV already loaded, creating animator now');
                initializeAnimator(blendshapeSequences);
            }
          } else {
            showError('No mesh with morph targets found in the model.');
          }

          showLoading(false);
        },
        (progress) => {
          const percent = (progress.loaded / progress.total * 100).toFixed(0);
          console.log('Loading:', percent + '%');
        },
        (error) => {
          console.error('Error loading model:', error);
          showError('Failed to load model. Check the URL and ensure CORS is enabled.');
          showLoading(false);
        }
      );
    }

    /**
     * Parse blendshape CSV data and organize by sequence
     * @param {string} csvString - The raw CSV content
     * @returns {Object} - Organized data structure with sequences
     */
    function parseBlendshapeData(csvString) {
        const results = Papa.parse(csvString, {
            header: true,              // First row contains column names
            dynamicTyping: true,       // Auto-convert numbers
            skipEmptyLines: true,      // Ignore empty rows
            trimHeaders: true          // Remove whitespace from headers
        });

        if (results.errors.length > 0) {
            console.error('CSV parsing errors:', results.errors);
        }

        // Organize data by sequence identifier
        const sequences = {};
        
        results.data.forEach(row => {
            const sequenceId = row.sequence_ID
            const frameId = row.frame
            const FPS = row.FPS
            
            if (!sequences[sequenceId]) {
                sequences[sequenceId] = [];
            }
            
            // Store the entire row (contains all blendshape coefficients)
            sequences[sequenceId].push({
                frame: frameId,
                fps: FPS,
                ...row  // Includes all blendshape coefficients
            });
        });

        console.log(`Parsed ${Object.keys(sequences).length} sequences`);
        Object.keys(sequences).forEach(seqId => {
            console.log(`Sequence ${seqId}: ${sequences[seqId].length} frames`);
        });

        return sequences;
    }

    // Reset all
    function resetAll() {
      if (!headMesh) return;
      headMesh.morphTargetInfluences.fill(0);
    }

    // UI helpers
    function showLoading(show) {
      loadingEl.style.display = show ? 'block' : 'none';
      loadBtn.disabled = show;
    }

    function showError(message) {
      errorMsg.textContent = message;
      errorMsg.style.display = 'block';
    }

    function hideError() {
      errorMsg.style.display = 'none';
    }

    // Event listeners
    loadBtn.addEventListener('click', () => {
      const url = modelUrlInput.value.trim();
      if (url) {
        loadModel(url);
      }
    });

    // Function to initialize everything after CSV loads
    function initializeAnimator(sequences) {
        animator = new BlendshapeAnimator(headMesh, sequences, 30);
        setupButtons();
        document.getElementById('controls').style.display = 'block';
        console.log('Animator ready!');
    }

    function setupButtons() {
        document.getElementById('btn-seq-1').addEventListener('click', () => {
            animator.play('1');
        });
        document.getElementById('btn-seq-2').addEventListener('click', () => {
            animator.play('2');
        });
        document.getElementById('btn-seq-3').addEventListener('click', () => {
            animator.play('3');
        });
        document.getElementById('btn-seq-4').addEventListener('click', () => {
            animator.play('4');
        });
        document.getElementById('btn-seq-5').addEventListener('click', () => {
            animator.play('5');
        });
        document.getElementById('btn-seq-6').addEventListener('click', () => {
            animator.play('6');
        });
        document.getElementById('btn-seq-7').addEventListener('click', () => {
            animator.play('7');
        });
        document.getElementById('btn-seq-8').addEventListener('click', () => {
            animator.play('8');
        });
    }

    resetBtn.addEventListener('click', resetAll);

    // Initialize
    initScene();
    loadModel('char.glb');

    // Load CSV file
    fetch('pauses.csv')
        .then(response => response.text())
        .then(csvString => {
            blendshapeSequences = parseBlendshapeData(csvString);
            if (headMesh) {
                console.log('headMesh:', headMesh);
                console.log('Has morphTargetInfluences?', headMesh?.morphTargetInfluences);
                initializeAnimator(blendshapeSequences);
            }
            
            // Now you can access sequences like: blendshapeSequences['sequence_1']
        })
        .catch(error => console.error('Error loading CSV:', error));

    
  </script>
</body>
</html>
