<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ready Player Me Blendshape Animation</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    a {
      color: #60a5fa;
    }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #111827;
      color: white;
      display: flex;
      flex-direction: row; /* Change from column to row */
      height: 100vh;
      overflow: hidden;
    }
    .header {
      background: #191818;
      padding: 1rem;
      box-shadow: -2px 0 4px rgba(0,0,0,0.3); /* Shadow on left instead of bottom */
      width: 20%; /* Fixed width for the sidebar */
      height: 100vh; /* Full viewport height */
      max-height: none; /* Remove the max-height restriction */
      overflow-y: auto;
      position: fixed; /* Fix it to the viewport */
      right: 0; /* Align to right edge */
      top: 0;
    }
    h1 {
      font-size: 1.5rem;
      margin-bottom: 0.75rem;
    }
    .info-box {
      background:#191818;
      padding: 0.75rem;
      border-radius: 0.375rem;
      margin-bottom: 1rem;
    }
    .info-box p {
      color: #bfdbfe;
      font-size: 0.875rem;
      margin-bottom: 0.5rem;
    }
    .info-box ol {
      color: #bfdbfe;
      font-size: 0.875rem;
      margin-left: 1.25rem;
    }
    .info-box ol li {
      margin-bottom: 0.25rem;
    }
    .info-box a {
      color: #60a5fa;
      text-decoration: underline;
    }
    .url-input-group {
      display: block;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    .url-input-group input {
      padding: 0.5rem;
      background: #374151;
      color: white;
      border: 1px solid #4b5563;
      border-radius: 0.375rem;
      font-size: 0.875rem;
    }
    .url-input-group button {
      padding: 0.5rem 1.5rem;
      background: #585C1F;
      color: white;
      border: none;
      border-radius: 0.375rem;
      font-weight: 500;
      cursor: pointer;
    }
    .url-input-group button:hover {
      background: #585C1F;
    }
    .url-input-group button:disabled {
      background: #4b5563;
      cursor: not-allowed;
    }
    .error {
      background: #7f1d1d;
      color: #fecaca;
      padding: 0.75rem;
      border-radius: 0.375rem;
      margin-bottom: 1rem;
      font-size: 0.875rem;
    }
    .controls-panel {
      padding: 1rem;
      border-bottom: 1px solid #374151;
    }
    .control-group {
      margin-bottom: 1rem;
    }
    .control-group:last-child {
      margin-bottom: 0;
    }
    .control-group label {
      display: block;
      color: #e5e7eb;
      font-size: 2rem;
      margin-bottom: 0.375rem;
      font-weight: 500;
    }
    .control-group select {
      width: 100%;
      padding: 0.5rem;
      background: #374151;
      color: white;
      border: 1px solid #4b5563;
      border-radius: 0.375rem;
      font-size: 0.875rem;
    }
    .slider-container {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    .slider-container input[type="range"] {
      flex: 1;
    }
    .slider-value {
      color: #60a5fa;
      font-weight: 600;
      min-width: 3rem;
      text-align: right;
      font-size: 0.875rem;
    }
    .button-group {
      display: flex;
      gap: 0.5rem;
      margin-top: 1rem;
    }
    .button-group button {
      padding: 0.5rem 1rem;
      background: #585C1F;
      color: white;
      border: none;
      border-radius: 0.375rem;
      font-size: 0.875rem;
      cursor: pointer;
      font-weight: 500;
    }
    .button-group button:hover {
      background:rgb(52, 54, 14);
    }
    #container {
      flex: 1;
      position: relative;
      cursor: grab;
      margin-right: 20%; /* Add margin to account for fixed sidebar width */
    }
    #container:active {
      cursor: grabbing;
    }
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #585C1F;
      font-size: 1.25rem;
      font-weight: 500;
    }
  </style>
</head>
<body>
  <div class="header">
    
    <div class="controls-panel" id="controls" style="display: none;">
      <div class="control-group">
        <label for="blendshape-select">Blendshape (<span id="blendshape-count">0</span> available):</label>
        <select id="blendshape-select"></select>
      </div>
      <div class="control-group">
        <label for="intensity-slider">Intensity:</label>
        <div class="slider-container">
          <input type="range" id="intensity-slider" min="0" max="1" step="0.01" value="0">
          <span class="slider-value" id="intensity-value">0.00</span>
        </div>
      </div>
            <div class="button-group">
        <button id="reset-btn">Reset All</button>
      </div>
    </div>

    <div class="url-input-group">
      <div>This model was created using <a href="https://readyplayer.me">Ready Player Me</a>, a service for creating 3D avatars.</div>
      <div>You can create your own model and load it here:</div>
      <input 
        type="text" 
        id="model-url" 
        placeholder="https://models.readyplayer.me/your-avatar-id.glb"
        value="">
      <button id="load-btn">Load Model</button>
    </div>

    <div id="error-msg" class="error" style="display: none;"></div>
  </div>
  
  <div id="container">
    <div id="loading" style="display: none;">Loading model...</div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  
  <script>
    // DOM elements
    const container = document.getElementById('container');
    const modelUrlInput = document.getElementById('model-url');
    const loadBtn = document.getElementById('load-btn');
    const loadingEl = document.getElementById('loading');
    const errorMsg = document.getElementById('error-msg');
    const controlsPanel = document.getElementById('controls');
    const blendshapeSelect = document.getElementById('blendshape-select');
    const blendshapeCount = document.getElementById('blendshape-count');
    const intensitySlider = document.getElementById('intensity-slider');
    const intensityValue = document.getElementById('intensity-value');
    const resetBtn = document.getElementById('reset-btn');

    let scene, camera, renderer, controls;
    let headMesh = null;
    let model = null;
    let availableBlendshapes = [];

    // Initialize Three.js scene
    function initScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xF5F5F5);

      camera = new THREE.PerspectiveCamera(
        45,
        container.clientWidth / container.clientHeight,
        0.1,
        1000
      );
      camera.position.set(0, 0, 0.4);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.outputEncoding = THREE.sRGBEncoding;
      container.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.target.set(0, 0, 0);

      // Lighting - three-point setup
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const keyLight = new THREE.DirectionalLight(0xffffff, 0.8);
      keyLight.position.set(1, 1, 1);
      scene.add(keyLight);

      const fillLight = new THREE.DirectionalLight(0x6c63ff, 0.3);
      fillLight.position.set(-1, 0, -1);
      scene.add(fillLight);

      const backLight = new THREE.DirectionalLight(0xffffff, 0.2);
      backLight.position.set(0, 1, -1);
      scene.add(backLight);

      // Start animation loop
      animate();

      // Handle resize
      window.addEventListener('resize', () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      });
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    // Load model
    // Change what counts as the centre somewhere in here. Want middle of 
    // face.
    function loadModel(url) {
      showLoading(true);
      hideError();
      controlsPanel.style.display = 'none';

      // Remove previous model
      if (model) {
        scene.remove(model);
        model = null;
        headMesh = null;
      }

      const loader = new THREE.GLTFLoader();

      loader.load(
        url,
        (gltf) => {
          console.log('Model loaded successfully');
          model = gltf.scene;

          // Find mesh with morph targets
          let foundMesh = null;
          model.traverse((child) => {
            if (child.isMesh && child.morphTargetInfluences && child.morphTargetInfluences.length > 0) {
              foundMesh = child;
              console.log('Found mesh with morph targets:', child.name);
              console.log('Morph targets:', Object.keys(child.morphTargetDictionary || {}));
            }
          });

          if (foundMesh) {
            headMesh = foundMesh;
            availableBlendshapes = Object.keys(headMesh.morphTargetDictionary || {})
              .filter(key => !key.startsWith("viseme"));

            // Reset all influences
            headMesh.morphTargetInfluences.fill(0);

            // Update UI
            populateBlendshapeDropdown();
            blendshapeCount.textContent = availableBlendshapes.length;
            controlsPanel.style.display = 'block';

            // Add model to scene
            scene.add(model);

            // Center and scale model
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const scale = 2 / maxDim;
            model.scale.multiplyScalar(scale);
            box.setFromObject(model);
            box.getCenter(center);
            model.position.sub(center);
            
            // Find the head bone and position it at origin
            const leftEye = model.getObjectByName('LeftEye')
            const rightEye = model.getObjectByName('RightEye')
            
            if (leftEye) {
              const leftEyePosition = new THREE.Vector3();
              leftEye.getWorldPosition(leftEyePosition);
              const rightEyePosition = new THREE.Vector3();
              rightEye.getWorldPosition(rightEyePosition);
              middleOfEyes = leftEyePosition.clone().lerp(rightEyePosition, 0.5);
              model.position.sub(middleOfEyes);
              console.log('Middle of eyes positioned at origin');
            } else {
              console.warn('Head bone not found, using bounding box top instead');
              // Alternative: position top of bounding box at origin
              model.position.y += size.y * scale / 2;
            }
            

            console.log('Setup complete. Found', availableBlendshapes.length, 'blendshapes');
          } else {
            showError('No mesh with morph targets found in the model.');
          }

          showLoading(false);
        },
        (progress) => {
          const percent = (progress.loaded / progress.total * 100).toFixed(0);
          console.log('Loading:', percent + '%');
        },
        (error) => {
          console.error('Error loading model:', error);
          showError('Failed to load model. Check the URL and ensure CORS is enabled.');
          showLoading(false);
        }
      );
    }

    // Populate dropdown
    function populateBlendshapeDropdown() {
      blendshapeSelect.innerHTML = '';
      availableBlendshapes.forEach(name => {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        blendshapeSelect.appendChild(option);
      });
    }

    // Update blendshape
    function updateBlendshape() {
      if (!headMesh) return;

      const selectedName = blendshapeSelect.value;
      const intensity = parseFloat(intensitySlider.value);
      const index = headMesh.morphTargetDictionary[selectedName];

      if (index !== undefined) {
        // Reset all
        // headMesh.morphTargetInfluences.fill(0);
        // Set selected
        headMesh.morphTargetInfluences[index] = intensity;
      }

      intensityValue.textContent = intensity.toFixed(2);
    }

    // Simulate smile
    // Button removed, but sitting here as example of how to do a single 
    // gesture.
    function simulateSmile() {
      if (!headMesh) return;

      const coefficients = {
        mouthSmileLeft: 1,
        mouthSmileRight: 1,
        eyeBlinkLeft: 1,
        eyeBlinkRight: 1,
        browInnerUp: 1,
      };

      // Reset all
      headMesh.morphTargetInfluences.fill(0);

      // Apply coefficients
      Object.keys(coefficients).forEach(name => {
        const index = headMesh.morphTargetDictionary[name];
        if (index !== undefined) {
          headMesh.morphTargetInfluences[index] = coefficients[name];
        }
      });

      console.log('Applied simulated smile');
    }

    // Reset all
    function resetAll() {
      if (!headMesh) return;
      headMesh.morphTargetInfluences.fill(0);
      intensitySlider.value = 0;
      intensityValue.textContent = '0.00';
    }



    // UI helpers
    function showLoading(show) {
      loadingEl.style.display = show ? 'block' : 'none';
      loadBtn.disabled = show;
    }

    function showError(message) {
      errorMsg.textContent = message;
      errorMsg.style.display = 'block';
    }

    function hideError() {
      errorMsg.style.display = 'none';
    }

    // Event listeners
    loadBtn.addEventListener('click', () => {
      const url = modelUrlInput.value.trim();
      if (url) {
        loadModel(url);
      }
    });

    blendshapeSelect.addEventListener('change', updateBlendshape);
    intensitySlider.addEventListener('input', updateBlendshape);
    resetBtn.addEventListener('click', resetAll);
    // Initialize
    initScene();
    loadModel('char.glb');
  </script>
</body>
</html>
